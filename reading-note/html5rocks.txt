https://www.html5rocks.com/ja/tutorials/internals/howbrowserswork


* 2011年現在の話

* レンダリングエンジンはWebkit、Gecko、IE系の3つに大分類
* Chrome, Operaが実装するWebkit系、Firefoxが実装するGecko系でシェアが60%以上

* レンダリングエンジンは、HTML入力→描画までにいくつかの段階がある。
  * 参考: https://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/#Main_flow_examples

* レキサー・パーサーについて
  * 多少誤りのあるHTMLも描画するため、例えばWebkitはFlexやBisonといったパーサージェネレータ
    （BNF形式などのスクリプトから、C言語ベースのパーシング用コードを自動生成するライブラリ）
    を用いたテンプレートを更に手動でカスタマイズしている。つらそう。
  * いくつか知った事実
    * </br>はパーサーからすると面倒な構文だった
    * 入れ子のテーブルは外だしにする
    * フォームを入れ子にすると一番外側のものしか適応しなくなる
    * 同じタグでの入れ子は 20 個まで
    * </html> </body>は仕方ないので無視している（合理的だが衝撃的）

* レンダーツリーについて
  * DOMから更に、描画計算用にレンダーオブジェクトを生成、構造が似通ったツリーにする。
    * ただし、DOMと完全一致ではない。<select>タグはその最たる例で、テキスト、ボタン、展開時の選択内容などは1DOMに対し
      複数のレンダーオブジェクトになる。（レンダーオブジェクトは、C++のclassでサンプル提示されている）

* スタイルデータとルールツリーについて
  * Firefoxのはなし
    * レンダーツリーに連動して「ルールツリー」および「スタイルコンテキストツリー」という２つのツリーをもつ
    * ルールツリーは、CSSのスタイルを、順序良くマージしていくための整理につかわれる、
      (例: cssより div div { ... } があった場合、ツリーを走査して、前後を見て条件が一致したものをみて適応する）
    * ルールツリーにより、各スタイル・DOMの走査は1回で済む。
  * Webkitのはなし
    * 各ノードは「スタイル オブジェクト」を参照する
    * 例えば p { ... } のようにいくつものオブジェクトで共有できるようなスタイルは、1オブジェクトをメモリ中に生成
      各ノードは該当オブジェクトを参照する。
    * 各スタイル・DOMの走査は計4回行う。これらはハードコーディングしているのだろう。
      * 重要でないが優先度の高いプロパティ（他のプロパティがそのプロパティに依存しているため、最初に適用すべきプロパティ。display など）
      * 優先度の高い重要なルール
      * 通常の優先度で重要でないルール
      * 通常の優先度で重要なルール
  * スタイルには、「リセット型」「継承型」がある。
    * リセット型 ... その要素にしか適応しないもの。diaplayなど。
    * 継承型 ... 子要素にも継承されるもの。font-sizeなど。
  * スタイルにidやクラスを指定すると、別途idマップ・クラスマップといった辞書に追加され、マッチング処理が高速化。

* レイアウト（リフロー）について
  * ツリーごとの位置やサイズを計算すること
  * 解析後、JavaScriptなどでプロパティを変更したときに、再描画要否を見るためダーティビットが
    レンダリングオブジェクト毎に設定されている
  * グローバルレイアウト（全描画しなおし）とインクリメンタルレイアウト（dirtybitが立っているもののみ再描画）がある